---
title: "TableGen for instruction selection"
description: "Configuring the target for isel"
---
import CodeSnippet from "../../../components/CodeSnippet.astro";
import Details from "../../../components/Collapsible.astro";
import InlineComment from "../../../components/InlineComment.astro";
import { LinkCard, CardGrid, Aside } from "@astrojs/starlight/components";

We have looked at how the instruction selection works.
Here, we will see how you can select LLVM IR to your target's instruction set.

## TableGen
TableGen does a lot of heavy-lifting for us in the instruction selection process.
Refer to the [TableGen documentation](https://llvm.org/docs/TableGen/) for how to use TableGen.

> A TableGen introduction is coming soon to this site.

Essentially, we specify instructions and rules on how to match SDNodes to our instructions
by using TableGen records. Then, the instruction selection TableGen backend generates the 
necessary code to actually perform the selection.

<Aside>
This page is a work in progress. The intention is to provide a comprehensive documentation on how
to use TableGen for instruction selection.
The documentation is not complete yet, but we will be adding more information soon.
</Aside>

## Registers 
Before we can write any instruction, we must define some registers for our architecture.

Registers are quite simple, so refer directly to the [Adding Registers chapter](../section%201/02%20registers.mdx)
for how to define them.

### Register Classes
The important part in defining the register classes is the supported types of the class.
For example, MIPS defines the `GPR32` class for register supporting `i32` types:

```c
def GPR32 : GPR32Class<[i32]>;
```

AMDGPU defines the `VGPR` class for registers supporting `v4i32` types:

```js "Reg32Types.types, Reg16Types.types"
// VGPR 32-bit registers
// i16/f16 only on VI+
def VGPR_32 : SIRegisterClass<"AMDGPU", !listconcat(Reg32Types.types, Reg16Types.types), 32,
                            (add (sequence "VGPR%u", 0, 255))> {
  let AllocationPriority = 0;
  let Size = 32;
  let Weight = 1;
  let BaseClassOrder = 32;
}
...
// Types are defined as a list:
def Reg16Types : RegisterTypes<[i16, f16, bf16]>;
def Reg32Types : RegisterTypes<[i32, f32, v2i16, v2f16, v2bf16, p2, p3, p5, p6]>;

```

## Defining Instructions
Instructions refer to the `MachineInstr` class, which holds a `MCInstrDesc` object and are generated from
records that derive from the TableGen `Instruction` class.

The `MCInstrDesc` class describes the properties of an instruction, like:
- Opcode
- Arguments
- Arguments that are definitions
- Encoding size
- Implicit uses and defs
- Target-independent flags
- Target-specific flags

Instances of this class are created by the InstrInfo TableGen backend. The Opcodes are generated in the target's namespace
and are the same name as the records defined for each instruction.

<LinkCard href="https://llvm.org/docs/WritingAnLLVMBackend.html#instruction-set" title="Read more on LLVM docs"/>

## Types in TableGen
Types come from the `ValueTypes.td` file. Whenever a `valuetype` is used here, it refers to records
that subclass the `ValueType` class. Here are some examples:

```c
Integers: i1, i2, ... i128
Floating point: bf16, f16, f32... f128, ppcf128
Vectors: v1i1, ... v2048i1, v64i4, ...
ScalableVectors: nxv1i1 etc
```


<InlineComment comment="Need to verify the descriptions for these">Some special types are:</InlineComment>
- `Glue` - used for glue operands
- `OtherVT` - the "Other" value, used as the type of return values of nodes of opcodes like ISD::BasicBlock or ISD::Br.


Find all of them in the `llvm/include/llvm/CodeGen/ValueTypes.td` file.

## SD Nodes in TableGen
To describe patterns, we need to specify the SDNodes that we want to match.
An SDNode is defined by its type profile, opcode and node properties.

```c
Syntax:

def SDNodeName : SDNode<"XXXISD::OpcodeName", {type profile record}, [{node properties}...], {sdnode C++ class}>;
```

### Type Profile
Instances of this class are used to describe the types of the operands and results of the SDNode.

This uses a class called `SDTypeConstraint` to describe the input and output types of the SDNode.
TableGen has hardcoded a list of subclasses of `SDTypeConstraint` (like `SDTisFP`) that are documented in the 
`TargetSelectionDAG.td` file. 

To use these classes, we create anonymous records in the type profile.

The argument `int OpNum` is the operand number of the SDNode that we want to constrain. The 0th operand is the
return value of the SDNode's, and the operands of the SDNode are numbered from 1 to N.

---
To create a type profile, define a record that subclasses the `SDTypeProfile` class.

Here is an example:
```c
// SDTCisFP - The specified operand has floating-point type.
class SDTCisFP<int OpNum> : SDTypeConstraint<OpNum>;

// Use it by creating an anonymous record in the type profile like: SDTCisFP<0>
// Create a floating point binary operation in SDAG:

def SDFloatingBinaryOp :
             SDTypeProfile<
              1, // the number of result values
              2, // the number of operands
              [ SDTCisSameAs<0, 1>, 
                SDTCisSameAs<0, 2>, // all operands and result are same
                SDTCisFP<0> // all are floating point
              ]>;
```

There are loads of pre-defined type profiles in `TargetSelectionDAG.td` that you can use.
### SDNode Properties
The properties of the SDNode are defined in `SDNodeProperties.td` file.
<Details title="Show all properties">
<CodeSnippet id="sdnode-properties" />
</Details>

### SD Nodes
Targets can create their own SDNodes to match with this TableGen class.

MIPS uses an SDNode with the opcode `MIPSISD::Ret` to lower return instructions from LLVM IR to SDAG. This gets selected into
a RetRA machine pseudo instruction.

Here is the example from MIPSInstrInfo.td:
```c
// Return
def MipsRet : SDNode<"MipsISD::Ret", SDTNone,
                     [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;

// This is used in the RetRA instruction's inline pattern:
def RetRA : PseudoSE<(outs), (ins), [(MipsRet)]>;
```

## Patterns
Patterns in TableGen are used to match the SDNodes to the instructions.

### Syntax
To match a SDAG pattern, we use the `Pat` class. The following defines a single pattern:

```txt
def : Pat<(SDAG pattern to match), (instruction(s) to generate)>;
```

> Patterns can also be defined *inline*, in the Instruction record.

<Aside title="Yet to write" type="danger">
I am still working on writing this documentation for patterns in tablegen.
</Aside>
