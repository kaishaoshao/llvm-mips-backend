---
title: "Adding instructions"
description: Adding instructions for the Nova target.
---
import CodeSnippet from "../../../components/CodeSnippet.astro";
import Details from "../../../components/Collapsible.astro";
import {LinkCard} from "@astrojs/starlight/components";


<Details title="Instruction encodings" defaultOpen={true}>
Since we are not going to generate object code yet, we do not need to 
write the instruction encodings.
</Details>

To support instruction selection for the `Nova` target, we have to write
some tablegen and C++ code. Here is what we have to do:

1. Write instructions in `NovaInstrInfo.td`. These should cover all
instructions we want to support from the MIPS ISA.
2. We don't need encodings, so we move to the next step.
3. Write matching patterns in `NovaInstrPats.td` and `NovaISelDAGToDAG.cpp`. This is where we will
   implement the instruction selection.
4. Write the `NovaISelDAGToDAG.cpp` file to implement the instruction selection.
5. Write the `NovaISelLowering.cpp` file to implement the instruction lowering.


## Jump and Branch Instructions

First we need to create our TargetLowering class to tell
LLVM how to select instructions.

<CodeSnippet id="nova-isel-lowering-1"/>

Add the instructions in the td file.

<CodeSnippet id="nova-instr-info-1"/>

<Details title="Glue and chains">
<LinkCard
   href="https://groups.google.com/g/llvm-dev/c/F-GU_LiLOLs/m/CVETl5FwCQAJ"
   title="LLVM: Glue and chains"
   />
> Chains represent a dependency between nodes that can't be represented by a data dependency. For example a load following a store that might alias with the address of the load. The store must happen before the load. So the load's chain input is dependent on the store's chain output either directly or through other intermediate nodes that also have chain inputs and outputs. There can be multiple chains in parallel in the DAG. TokenFactor nodes are used to merge separate chains. The InstrEmitter ensures that the chain dependency is satisfied when emitting the linear instruction sequence after isel. But nothing guarantees that parallel chains won't be interleaved. After a node is schedule all of the nodes dependent on it either through data or chain are checked to see if they are now ready to schedule. The scheduler will pick from the ready to schedule nodes without any concern for whether they were on the same chain as the last node scheduled.
>
> Glue is stricter, it says that two nodes must be scheduled adjacent to each other in the linear instruction sequence.

</Details>

We now have to tell LLVM how to lower return instructions. This is done in the `TargetLowering` class.

<Details title="See the virtual method in TargetLowering">
This method must be implemented by targets.


<CodeSnippet noContext id="the-lower-return"/>

</Details>

But first, let's see how target calling conventions are defined.

Here are some types that are used for calling-convention information.

#### 1. `ISD::ArgFlagsTy`
This is a bitset that contains information about the argument. It is used to
   determine how the argument should be passed to the function.
<Details title="ISD::ArgFlagsTy">
<CodeSnippet noContext id="arg-flags"/>
</Details>

#### 2. `ISD::InputArg`
This struct contains the flags and type information about a single incoming (formal) argument or incoming return value virtual register.


<details title="MVT and EVT">
<summary>MVT and EVT</summary>
There are two fundamental classes that are used to represent types in LLVM: `MVT` and `EVT`.


#### 1. MVT
From the documentation:
> Machine Value Type. Every type that is supported natively by some
> processor targeted by LLVM occurs here. This means that any legal value
> type can be represented by an MVT.

It is basically a single `uint16_t` value that is used to represent the type. We can see all types listed in
`ValueTypes.td`. We can query the properties of the type using the `MVT` class methods. Some of them are pasted here for reference:

<CodeSnippet id="value-types-1" collapse="5-17"/>

#### 2. EVT
From the documentation:
> Extended Value Type. Capable of holding value types which are not native
> for any processor (such as the i12345 type), as well as the types an MVT
> can represent.

An EVT object holds an `MVT` value and an LLVM `Type` object.

We can initialize an `EVT` object in two ways shown below. Note that they can be implicitly casted from `MVT`.
<CodeSnippet noContext id="evt-init-1"/>
The two fields start off invalid for the default constructor.
<CodeSnippet noContext id="evt-members"/>
We then have a number of methods to query the type. Some of them are:
1. `isSimple()` - Returns true if the type is a simple type (i.e. not a vector or complex type).
Here "extended" means that this is not an MVT type but an LLVMTy.
2. `isInteger()` - Returns true if the type is an integer type.
and so on.
</details>

<CodeSnippet noContext id="input-arg"/>

#### 3. `ISD::OutputArg`
Same as `ISD::InputArg`, but for outgoing arguments. It is used to determine how the argument should be passed to the function.
<CodeSnippet noContext id="output-arg"/>


The next major structure is the `SelectionDAG` that is passed to the `LowerReturn` method. Let's take a look at that.

## `SelectionDAG`
<Details title="Move this section" type="tip">
This can be moved into its own page explaining the selection process.
</Details>
Each SDAG represents a single basic block in a function. In the instruction selection pipeline,
the DAG is constructed from the LLVM IR. Then the DAG is transformed into a target-specific DAG.

DAG is defined by the root and entry node.

// write about printing and reading the dag.

### Calling Conventions
LLVM defines a number of common calling conventions, represented by the `CallingConv::ID` as an enum value.

Some of them are `C`, `Fast`, `Cold` and some target-specific ones like `Win64` and `X86_64_SysV`. 

**CCValAssign**
This represents assignment of one arg/retval to a location.

Let's now implement the `LowerReturn` method in our `TargetLowering` class.

Setup the ISel Lowering file.
<CodeSnippet id="nova-isel-lowering-1"/>
Write the implementation.
<CodeSnippet id="nova-isel-lowering-cpp-1"/>

Now onto the LowerReturn method.

Let's consider an example of a return statement that needs to be lowered.

```llvm
define i64 @rett(i32 %a, i32 %b) {
entry:
    %aext = zext i32 %a to i64
    %bext = zext i32 %b to i64
    %ret = add i64 %aext, %bext
    ret i64 %ret
}
```
This is converted into this selection DAG:
```c {8,13}
Initial selection DAG: %bb.0 'rett:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i64 = zero_extend t2
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
    t6: i64 = zero_extend t4
  t7: i64 = add t5, t6
    t9: i32 = extract_element t7, Constant:i32<1>
  t13: ch,glue = CopyToReg t0, Register:i32 $v0, t9
    t11: i32 = extract_element t7, Constant:i32<0>
  t15: ch,glue = CopyToReg t13, Register:i32 $v1, t11, t13:1
  t16: ch = MipsISD::Ret t15, Register:i32 $v0, Register:i32 $v1, t15:1
```
We see that the return instruction returns two values for one i64 value. This is because the MIPS ABI requires that all values be returned in registers. The return value is split into two 32-bit values.

The `LowerReturn` method is responsible for lowering the return instruction. It does this by iterating over the return values and creating a new `SDNode` for each value. The `SDNode` is then added to the DAG.

<CodeSnippet id="nova-isel-lowering-cpp-2"/>

To get this method running, we need to implement the `NovaTargetMachine` and `NovaSubtarget` classes. These classes are responsible for providing information about the target architecture and the target machine.

## Subtarget
Some part of the subtarget class is generated by tablegen.

<CodeSnippet id="nova-subtarget-1"/>
