---
title: "The Return Instruction"
description: Here we add the return instruction for the Nova target.
sidebar:
  order: 5
---
import InlineComment from "../../../components/InlineComment.astro";
import CodeSnippet from "../../../components/CodeSnippet.astro";
import Details from "../../../components/Collapsible.astro";
import {LinkCard} from "@astrojs/starlight/components";


<Details title="Instruction encodings" defaultOpen={true}>
Since we are not going to generate object code yet, we do not need to 
write the instruction encodings.
</Details>

To support instruction selection for the `Nova` target, we have to write
some tablegen and C++ code. Here is what we have to do:

1. Write instructions in `NovaInstrInfo.td`. These should cover all
instructions we want to support from the MIPS ISA.
> Normally you want to add instruction encodings in 1, but we don't need encodings for compiling to assembly. We just move to the next step.
2. Write matching patterns in `NovaInstrPats.td`. This is where we implement the instruction selection.
3. Write the `NovaISelLowering.cpp` file to lower LLVM code to the target-specific SelectionDAG nodes.
4. Write the `NovaISelDAGToDAG.cpp` file to implement the instruction selection.

You'll know what each step means when we get to it.

## Instruction Selection
<Details title="Explain how selection works">
> Remove this section and just link to the previous Instruction Selection pages.

LLVM uses a two-phase process to select instructions.

Most of the time, TableGen will generate the patterns for you.

Selection phase is: LLVM IR -> SelectionDAG --optimize--> SelectionDAG -> Target-specific SelectionDAG --optimize--> Target-specific SelectionDAG

Lowering phase is: Target-specific SelectionDAG --optimize, then lower--> Target-specific SelectionDAG -> MachineInstr --optimize--> MachineInstr

</Details>

## Adding the Return Instruction
To define Nova's instructions, we need to write entries for each instruction as a TableGen record that
is an instance of the `Instruction` class. This is done in the `NovaInstrInfo.td` file.

### Instruction formats

Since instructions have a certain encoding format like rs, rt, rd, shamt, funct and others, we usually
define these formats in the `XXXInstrFormats.td` file. Read the `Target.td` file
(`llvm/include/llvm/Target/Target.td`) to see how the instruction formats are defined.

Let's add our file `NovaInstrFormats.td` to the `llvm/lib/Target/Nova/` directory.
<CodeSnippet id="nova-instr-formats-1"/>

Since we are not going to generate object code yet, we do not need to
add the instruction encoding formats. We will just create a simple base class
for Nova instructions.
<CodeSnippet id="nova-instr-formats-2"/>

Remember that the instructions we define are the MachineInstrs that LLVM IR instructions map
to. Ideally, these match the target's instruction set architecture (ISA) instructions.

But sometimes we need additional instructions that are not part of the ISA. These are called "pseudo instructions".
Pseudo instructions are not real instructions, but they are used to represent a sequence of real instructions. They are used to simplify the instruction selection process and to work more easily.

For example, the MIPS backend uses `PseudoRet` to represent a return instruction. `PseudoRet` is then printed as `jr` or
`jalr` depending on the MIPS Version ISA.

Let's add a Pseudo instruction class for Nova instructions.
<CodeSnippet id="nova-instr-formats-3"/>


### Defining the instruction
We'll start with the return instruction.

Create the `NovaISD::Ret` enum value. <InlineComment comment="Verify this: Probably was in LLVM weekly">Right now, these enum values are not generated by TableGen,
but in a future version they might be.</InlineComment>

<CodeSnippet id="nova-isel-lowering-1"/>

While we are in this file, add the `NovaTargetLowering` class. This is responsible for
lowering LLVM IR to the target-specific DAG nodes.
<CodeSnippet id="nova-isel-lowering-2" collapse="9-31"/>

Add the SDNode that LLVM IR's `ret` maps to. The opcode of this node is `NovaISD::Ret` and it takes
a variable number of operands. This is to support multiple return value registers (like returning an i64 value
needs two i32 registers, in `$v0` and `$v1`).
<CodeSnippet id="nova-return-td-1"/>

This node will get selected to the `PseudoRet` instruction.
<CodeSnippet id="nova-pseudo-ret"/>


All target tablegen files are included in the top-level `XXX.td` file.
Include the new `NovaInstrInfo.td` file in `Nova.td`:
<CodeSnippet id="nova-instr-info-td-include"/>

With this, we have defined everything required to support the return instruction.

### Lowering to SelectionDAG
We have to tell the `SelectionDAGBuilder` how to lower the LLVM IR `ret` instruction to Nova's SDNodes.

More specifically, we have to construct physical register nodes for the return values and insert the actual return SDNode. This is done in the `LowerReturn` method of the `TargetLowering` class.

Spin up the `NovaISelLowering.cpp` file.
<CodeSnippet id="nova-isel-lowering-cpp-init"/>

We have to declare legal types for the target. This is done in the `NovaTargetLowering` constructor.
<CodeSnippet id="nova-isel-lowering-cpp-1"/>

Now implement the `LowerReturn` method.
<CodeSnippet id="nova-isel-lowering-ret-lower-1"/>

The `Outs` vector contains the 

## Jump and Branch Instructions

First we need to create our TargetLowering class to tell
LLVM how to select instructions.

{/* <CodeSnippet id="nova-isel-lowering-1"/> */}

Add the instructions in the td file.

{/* <CodeSnippet id="nova-instr-info-1"/> */}

{/* <Details title="Glue and chains">
<LinkCard
   href="https://groups.google.com/g/llvm-dev/c/F-GU_LiLOLs/m/CVETl5FwCQAJ"
   title="LLVM: Glue and chains"
   />
> Chains represent a dependency between nodes that can't be represented by a data dependency. For example a load following a store that might alias with the address of the load. The store must happen before the load. So the load's chain input is dependent on the store's chain output either directly or through other intermediate nodes that also have chain inputs and outputs. There can be multiple chains in parallel in the DAG. TokenFactor nodes are used to merge separate chains. The InstrEmitter ensures that the chain dependency is satisfied when emitting the linear instruction sequence after isel. But nothing guarantees that parallel chains won't be interleaved. After a node is schedule all of the nodes dependent on it either through data or chain are checked to see if they are now ready to schedule. The scheduler will pick from the ready to schedule nodes without any concern for whether they were on the same chain as the last node scheduled.
>
> Glue is stricter, it says that two nodes must be scheduled adjacent to each other in the linear instruction sequence.

</Details> */}

We now have to tell LLVM how to lower return instructions. This is done in the `TargetLowering` class.

<Details title="See the virtual method in TargetLowering">
This method must be implemented by targets.


{/* <CodeSnippet noContext id="the-lower-return"/> */}

</Details>

But first, let's see how target calling conventions are defined.

Here are some types that are used for calling-convention information.

#### 1. `ISD::ArgFlagsTy`
This is a bitset that contains information about the argument. It is used to
   determine how the argument should be passed to the function.
<Details title="ISD::ArgFlagsTy">
<CodeSnippet noContext id="arg-flags"/>
</Details>

#### 2. `ISD::InputArg`
This struct contains the flags and type information about a single incoming (formal) argument or incoming return value virtual register.

<CodeSnippet noContext id="input-arg"/>

#### 3. `ISD::OutputArg`
Same as `ISD::InputArg`, but for outgoing arguments. It is used to determine how the argument should be passed to the function.
<CodeSnippet noContext id="output-arg"/>


The next major structure is the `SelectionDAG` that is passed to the `LowerReturn` method. Let's take a look at that.

## `SelectionDAG`
<Details title="Move this section" type="tip">
This can be moved into its own page explaining the selection process.
</Details>
Each SDAG represents a single basic block in a function. In the instruction selection pipeline,
the DAG is constructed from the LLVM IR. Then the DAG is transformed into a target-specific DAG.

DAG is defined by the root and entry node.

// write about printing and reading the dag.

### Calling Conventions
LLVM defines a number of common calling conventions, represented by the `CallingConv::ID` as an enum value.

Some of them are `C`, `Fast`, `Cold` and some target-specific ones like `Win64` and `X86_64_SysV`. 

**CCValAssign**
This represents assignment of one arg/retval to a location.

Let's now implement the `LowerReturn` method in our `TargetLowering` class.

Setup the ISel Lowering file.
{/* <CodeSnippet id="nova-isel-lowering-1"/> */}
Write the implementation.
{/* <CodeSnippet id="nova-isel-lowering-cpp-1"/> */}

Now onto the LowerReturn method.

Let's consider an example of a return statement that needs to be lowered.

```c
define i64 @rett(i32 %a, i32 %b) {
entry:
    %aext = zext i32 %a to i64
    %bext = zext i32 %b to i64
    %ret = add i64 %aext, %bext
    ret i64 %ret
}
```
This is converted into this selection DAG:
```c {8,13}
Initial selection DAG: %bb.0 'rett:entry'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i64 = zero_extend t2
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
    t6: i64 = zero_extend t4
  t7: i64 = add t5, t6
    t9: i32 = extract_element t7, Constant:i32<1>
  t13: ch,glue = CopyToReg t0, Register:i32 $v0, t9
    t11: i32 = extract_element t7, Constant:i32<0>
  t15: ch,glue = CopyToReg t13, Register:i32 $v1, t11, t13:1
  t16: ch = MipsISD::Ret t15, Register:i32 $v0, Register:i32 $v1, t15:1
```
We see that the return instruction returns two values for one i64 value. This is because the MIPS ABI requires that all values be returned in registers. The return value is split into two 32-bit values.

The `LowerReturn` method is responsible for lowering the return instruction. It does this by iterating over the return values and creating a new `SDNode` for each value. The `SDNode` is then added to the DAG.

{/* <CodeSnippet id="nova-isel-lowering-cpp-2"/> */}

To get this method running, we need to implement the `NovaTargetMachine` and `NovaSubtarget` classes. These classes are responsible for providing information about the target architecture and the target machine.

## Subtarget
Some part of the subtarget class is generated by tablegen.

{/* <CodeSnippet id="nova-subtarget-1"/> */}
